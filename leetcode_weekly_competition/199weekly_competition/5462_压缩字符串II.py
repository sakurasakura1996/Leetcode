"""
行程长度编码 是一种常用的字符串压缩方法，它将连续的相同字符（重复 2 次或更多次）替换为字符和表示字符计数的数字（行程长度）。
例如，用此方法压缩字符串 "aabccc" ，将 "aa" 替换为 "a2" ，"ccc" 替换为` "c3" 。因此压缩后的字符串变为 "a2bc3" 。
注意，本问题中，压缩时没有在单个字符后附加计数 '1' 。
给你一个字符串 s 和一个整数 k 。你需要从字符串 s 中删除最多 k 个字符，以使 s 的行程长度编码长度最小。
请你返回删除最多 k 个字符后，s 行程长度编码的最小长度 。
示例 1：
输入：s = "aaabcccd", k = 2
输出：4
解释：在不删除任何内容的情况下，压缩后的字符串是 "a3bc3d" ，长度为 6 。最优的方案是删除 'b' 和 'd'，这样一来，压缩后的字符串为 "a3c3" ，长度是 4 。

示例 2：
输入：s = "aabbaa", k = 2  这个示例有点关键啊
输出：2
解释：如果删去两个 'b' 字符，那么压缩后的字符串是长度为 2 的 "a4" 。

示例 3：
输入：s = "aaaaaaaaaaa", k = 0
输出：3
解释：由于 k 等于 0 ，不能删去任何字符。压缩后的字符串是 "a11" ，长度为 3 。
"""
# 做到这个题目的时候，感觉和之前某个题目很像，动态规划上很像problem410 分割数组的最大值,我日，应该不一样，这个还要难很多，看别人题解这里
# 动态规划的思路应该有四维dp
# 当时在做的时候，大概知道还是需要用动态规划。
# 1.状态的定义： 首先将题意转换成从字符串中，选取 T = n - k字符，使编码长度最小
#   定义 dp[p][cnt]  p-从字符串的第p位开始， cnt-当前已经选取了cnt个字符
# 2.状态的转移： 我们可以从当前位置p开始向后遍历，只要发现后面有字符和s[p]相等，则选取，这样我们可以枚举选取的字符数量，进行状态转移
# 比如，字符串 s = 'aabaaca' p=0,则我们可以从位置0开始，选择1个a，2个a，直到5个a，然后再在之后的字符串中选取字符。

class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int: