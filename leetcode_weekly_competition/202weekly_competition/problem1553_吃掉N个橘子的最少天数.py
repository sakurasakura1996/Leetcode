"""
1553. 吃掉 N 个橘子的最少天数
厨房里总共有 n 个橘子，你决定每一天选择如下方式之一吃这些橘子：
吃掉一个橘子。
如果剩余橘子数 n 能被 2 整除，那么你可以吃掉 n/2 个橘子。
如果剩余橘子数 n 能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子。
每天你只能从以上 3 种方案中选择一种方案。
请你返回吃掉所有 n 个橘子的最少天数。

示例 1：
输入：n = 10
输出：4
解释：你总共有 10 个橘子。
第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。
第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除）
第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。
第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。
你需要至少 4 天吃掉 10 个橘子。

示例 2：
输入：n = 6
输出：3
解释：你总共有 6 个橘子。
第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除）
第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除）
第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。
你至少需要 3 天吃掉 6 个橘子。

示例 3：
输入：n = 1
输出：1

示例 4：
输入：n = 56
输出：6
提示：
1 <= n <= 2*10^9
"""
# 看到这题，我想到的是动态规划，但是这道题n的范围上界是  2*10^9也太大了。
# 如果我们每次都优先将数减到能够被3整除，那么是否存在一个数，是这样并不是最优解呢，有比如38，它的最优解应该是直接就开始减2.而不是减到能够整除3.
from functools import lru_cache
class Solution:
    # 这里dfs的思考就是，当n较大时，必定要通过组合策略来使数据量快速减少，设dfs(n)表示吃n个橘子的最小天数
    # 要么，先用x = n % 2天，吃掉x = n % 2个，使n - x为2的倍数，然后用1天吃掉(n - x) / 2个，剩余(n - x) / 2个，问题变成吃(n - x) / 2
    # 个橘子的子问题。即，dfs(n) = (n % 2) + 1 + dfs((n - (n % 2)) / 2) = (n % 2) + 1 + dfs(n / 2)。

    # 要么，先用x = n % 3天，吃掉x = n % 3个，使n - x为3的倍数，然后用1天吃掉2(n - x) / 3个，剩余(n - x) / 3个，问题变成吃(n - x) / 3
    # 个橘子的子问题。即，dfs(n) = (n % 3) + 1 + dfs((n - (n % 3)) / 3) = (n % 3) + 1 + dfs(n / 3)。
    # dfs(n)
    # 就是这两种选择的最小值。同时使用记忆化可以减少重复计算，达到AC效果。
    @lru_cache(None)
    def minDays(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1
        return 1 + min(self.minDays(n//2) + n%2, self.minDays(n//3) + n%3)

class Solution2:
    # 一共有5种吃法
    # 吃n / 2个
    # 吃(n - 1) / 2个
    # 吃n / 3个
    # 吃(n - 1) / 3个
    # 吃(n - 2) / 3个
    # 直接使用暴力法
    # 提交运行结果竟然比上面的方法还省时间一些。
    def minDays(self, n: int) -> int:
        @lru_cache(None)
        def dfs(num):
            if num == 1:
                return 1
            eat1, eat2, eat3, eat4, eat5 = 233333333, 233333333, 233333333, 233333333, 233333333
            if num % 2 != 0 and num > 1:
                eat1 = dfs((num - 1) // 2) + 2
            if (num - 1) % 3 == 0 and num > 1:
                eat2 = dfs((num - 1) // 3) + 2
            if (num - 2) % 3 == 0 and num > 2:
                eat3 = dfs((num - 2) // 3) + 3
            if num % 2 == 0:
                eat4 = dfs(num // 2) + 1
            if num % 3 == 0:
                eat5 = dfs(num // 3) + 1
            ans = min(eat1, eat2, eat3, eat4, eat5)
            return ans

        return dfs(n)





        
